{"ast":null,"code":"const BufferList = require('bl/BufferList');\n\nconst TypeDefault = {\n  string: () => '',\n  buffer: () => BufferList()\n};\n\nmodule.exports = async (source, options) => {\n  options = options || {};\n\n  if (options.type && !TypeDefault[options.type]) {\n    throw new Error(`invalid type \"${options.type}\"`);\n  }\n\n  let res, type;\n\n  for await (const chunk of source) {\n    if (!res) {\n      type = options.type || typeof chunk === 'string' ? 'string' : 'buffer';\n      res = TypeDefault[type]();\n    }\n\n    if (type === 'string') {\n      res += chunk;\n    } else {\n      res.append(chunk);\n    }\n  }\n\n  return res || TypeDefault[options.type || 'buffer']();\n};","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/DAPP-master-dup/DAPP-master/client/node_modules/it-concat/index.js"],"names":["BufferList","require","TypeDefault","string","buffer","module","exports","source","options","type","Error","res","chunk","append"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AAEA,MAAMC,WAAW,GAAG;AAClBC,EAAAA,MAAM,EAAE,MAAM,EADI;AAElBC,EAAAA,MAAM,EAAE,MAAMJ,UAAU;AAFN,CAApB;;AAKAK,MAAM,CAACC,OAAP,GAAiB,OAAOC,MAAP,EAAeC,OAAf,KAA2B;AAC1CA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,MAAIA,OAAO,CAACC,IAAR,IAAgB,CAACP,WAAW,CAACM,OAAO,CAACC,IAAT,CAAhC,EAAgD;AAC9C,UAAM,IAAIC,KAAJ,CAAW,iBAAgBF,OAAO,CAACC,IAAK,GAAxC,CAAN;AACD;;AAED,MAAIE,GAAJ,EAASF,IAAT;;AACA,aAAW,MAAMG,KAAjB,IAA0BL,MAA1B,EAAkC;AAChC,QAAI,CAACI,GAAL,EAAU;AACRF,MAAAA,IAAI,GAAGD,OAAO,CAACC,IAAR,IAAgB,OAAOG,KAAP,KAAiB,QAAjC,GAA4C,QAA5C,GAAuD,QAA9D;AACAD,MAAAA,GAAG,GAAGT,WAAW,CAACO,IAAD,CAAX,EAAN;AACD;;AAED,QAAIA,IAAI,KAAK,QAAb,EAAuB;AACrBE,MAAAA,GAAG,IAAIC,KAAP;AACD,KAFD,MAEO;AACLD,MAAAA,GAAG,CAACE,MAAJ,CAAWD,KAAX;AACD;AACF;;AAED,SAAOD,GAAG,IAAIT,WAAW,CAACM,OAAO,CAACC,IAAR,IAAgB,QAAjB,CAAX,EAAd;AACD,CAtBD","sourcesContent":["const BufferList = require('bl/BufferList')\n\nconst TypeDefault = {\n  string: () => '',\n  buffer: () => BufferList()\n}\n\nmodule.exports = async (source, options) => {\n  options = options || {}\n\n  if (options.type && !TypeDefault[options.type]) {\n    throw new Error(`invalid type \"${options.type}\"`)\n  }\n\n  let res, type\n  for await (const chunk of source) {\n    if (!res) {\n      type = options.type || typeof chunk === 'string' ? 'string' : 'buffer'\n      res = TypeDefault[type]()\n    }\n\n    if (type === 'string') {\n      res += chunk\n    } else {\n      res.append(chunk)\n    }\n  }\n\n  return res || TypeDefault[options.type || 'buffer']()\n}\n"]},"metadata":{},"sourceType":"script"}